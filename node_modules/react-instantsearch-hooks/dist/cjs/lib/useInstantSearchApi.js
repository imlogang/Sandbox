"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInstantSearchApi = useInstantSearchApi;

var _InstantSearch = _interopRequireDefault(require("instantsearch.js/cjs/lib/InstantSearch"));

var _react = require("react");

var _shim = require("use-sync-external-store/shim");

var _useInstantSearchServerContext = require("../lib/useInstantSearchServerContext");

var _useInstantSearchSSRContext = require("../lib/useInstantSearchSSRContext");

var _version = _interopRequireDefault(require("../version"));

var _useForceUpdate = require("./useForceUpdate");

var _useStableValue = require("./useStableValue");

var defaultUserAgents = ["react (".concat(_react.version, ")"), "react-instantsearch (".concat(_version.default, ")"), "react-instantsearch-hooks (".concat(_version.default, ")")];

function useInstantSearchApi(props) {
  var forceUpdate = (0, _useForceUpdate.useForceUpdate)();
  var serverContext = (0, _useInstantSearchServerContext.useInstantSearchServerContext)();
  var serverState = (0, _useInstantSearchSSRContext.useInstantSearchSSRContext)();
  var initialResults = serverState === null || serverState === void 0 ? void 0 : serverState.initialResults;
  var stableProps = (0, _useStableValue.useStableValue)(props);
  var search = (0, _react.useMemo)(function () {
    var instance = new _InstantSearch.default(stableProps);

    if (serverContext || initialResults) {
      // InstantSearch.js has a private Initial Results API that lets us inject
      // results on the search instance.
      // On the server, we default the initial results to an empty object so that
      // InstantSearch.js doesn't schedule a search that isn't used, leading to
      // an additional network request. (This is equivalent to monkey-patching
      // `scheduleSearch` to a noop.)
      instance._initialResults = initialResults || {};
    }

    addAlgoliaAgents(props.searchClient, [].concat(defaultUserAgents, [serverContext && "react-instantsearch-server (".concat(_version.default, ")")]));
    return instance;
  }, [initialResults, props.searchClient, serverContext, stableProps]);
  var store = (0, _shim.useSyncExternalStore)((0, _react.useCallback)(function () {
    // On SSR, the instance is already started so we don't start it again here.
    if (!search.started) {
      search.start();
      forceUpdate();
    }

    return function () {
      search.dispose();
    };
  }, [forceUpdate, search]), function () {
    return search;
  }, function () {
    return search;
  });

  if (!search.started) {
    // On the server, we start the search early to compute the search parameters.
    // On SSR, we start the search early to directly catch up with the lifecycle
    // and render.
    if (serverContext || initialResults) {
      search.start();
    }

    if (serverContext) {
      // We notify `getServerState()` of the InstantSearch internals to retrieve
      // the server state and pass it to the render on SSR.
      serverContext.notifyServer({
        search: search
      });
    }
  }

  return store;
}

function addAlgoliaAgents(searchClient, userAgents) {
  if (typeof searchClient.addAlgoliaAgent !== 'function') {
    return;
  }

  userAgents.filter(Boolean).forEach(function (userAgent) {
    searchClient.addAlgoliaAgent(userAgent);
  });
}